# http://localhost:8081/api/polaznici
# http://localhost:8081/api/upisi/polaznik/1

# ----------------------------------------------------------------------------

spring.jpa.open-in-view=false

# ----------------------------------------------------------------------------

# Hibernate automatsko generiranje i azuriranje database schema (i tablica)
#
spring.jpa.hibernate.ddl-auto=create-drop
#
# Objasnjenje opcija:
# create - Dropa postojece tablice i ponovo ih kreira pri svakom pokretanju.
# create-drop - Isto kao create, ali dropa tablice pri gasenju aplikacije.
# update - Kreira tablice ako ne postoje i azurira shemu ako promjenis entitete.
# validate - Samo provjerava je li shema ispravna s entitetima, ne mijenja nista.
# none - ne mijenjaj schema, koristi postojecu, ne kreiraj nista

# Dodatna Hibernate konfiguracija za automatsko generiranje schema (i tablica)
#
spring.jpa.properties.hibernate.hbm2ddl.auto=create-drop
#
# Vazece vrijednosti:
#   Hibernate nece mijenjati shemu baze podataka, ne pokusava sync-ovati model sa bazom
#   Koristi se kada rucno upravljate migracijama (Flyway/Liquibase) ili imate fiksnu shemu
# validate
#   Samo provjerava podudarnost izmedu Java entiteta i database sheme
#   Bacit ce iznimku ako postoji neslaganje
#   Ne mijenja bazu podataka
# update (korisno za razvoj)
#   Azurira shemu baze da odgovara entitetima
#   Dodaje nove kolone/tablice, ali ne brise postojece
#   Nije preporucljivo za produkciju - moze uzrokovati gubitak podataka
# create
#   Uvijek brise i ponovo kreira cijelu shemu pri pokretanju
#   Gubi sve postojece podatke!
#   Korisno za testiranje, nikad za produkciju
# create-drop
#   Kao create, ali dodatno brise shemu pri gasenju aplikacije
#   Korisno za integrirano testiranje

# ----------------------------------------------------------------------------

# Postavlja Hibernate PhysicalNamingStrategy na standardnu user defined implementaciju
# koja NE modificira case (velika/mala slova) naziva tabela i kolona
# Ovo sprjecava automatsku konverziju u lowercase
# Znaci da ce Hibernate tocno koristiti imena kolona i tablica kako ste ih definirali
# u vasim JPA anotacijama, bez ikakvih automatskih transformacija
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# ----------------------------------------------------------------------------

# Omogucava izvrsavanje SQL skripti pri pokretanju aplikacije
spring.sql.init.mode=always

# Ako koristite standardna imena za SQL skripte (data.sql, schema.sql, cleanup.sql),
# Spring Boot ce ih automatski prepoznati i izvrsiti bez potrebe za eksplicitnim
# navodjenjem putanja u application.properties

# Lokacija SQL schema.sql skripte za kreiranje database SCHEMA (DDL - CREATE TABLE tj. kreiranje tablica itd.)
# Skripta se nalazi u resources folderu (classpath)
# schema.sql se izvrsi prva (kreiranje tablica), a data.sql druga (ubacivanje podataka u tablice)
#spring.sql.init.schema-locations=classpath:schema.sql

# Lokacija SQL data.sql skripte za popunjavanje DATA podataka u tablice (DML - INSERT DATA itd)
# Skripta se nalazi u resources folderu (classpath)
spring.sql.init.data-locations=classpath:data.sql

# Ako je ova dolje komanda false (default):
# Prvo se izvrsavaju schema.sql i data.sql (rucne SQL skripte).
# Tek nakon toga Hibernate pokrece ddl-auto (create, update itd.).
# Ovo moze uzrokovati greske:
# Ako schema.sql definira tablice, a Hibernate ih pokusava kreirati opet.
# Ako ddl-auto=update, Hibernate moze ocekivati da tablice vec postoje.
# Ako je true:
# Hibernate ce prvi izvrsiti ddl-auto (create, update itd.) i kreirati tablice prema entitetima.
# Tek nakon toga se izvrsavaju schema.sql i data.sql.
# Ovo omogucava da skripte za unos podataka (data.sql) rade sigurno jer su tablice vec \
# kreirane od strane Hibernate-a.
# Kada koristiti spring.jpa.defer-datasource-initialization=true?
# Koristi kada:
# Koristis data.sql za unos testnih/pocetnih podataka.
# Koristis Hibernate ddl-auto=create / update za automatsko kreiranje tablica.
# Zelis da Hibernate prvo kreira strukturu, a tek onda da se podaci ubace.
# Ne treba ti ako rucno kontroliras migracije (Flyway/Liquibase) ili koristis iskljucivo \
# rucne schema.sql skripte za kreiranje tablica.
spring.jpa.defer-datasource-initialization=true

# Formatira generirane SQL upite za ljepsi prikaz u logovima
# formatira generirane SQL upite koje Hibernate salje bazi podataka, cineci ih citljivijim u logovima.
# sto radi?
# Automatski dodaje razmake i novi redak u SQL upite
# Poboljsava preglednost kompleksnih upita (npr. s JOIN-ovima)
# Primjer:
# Bez formatiranja:
# SELECT u.name, u.email FROM User u WHERE u.id = 1
# Sa formatiranjem:
# SELECT
#     u.name,
#     u.email
# FROM
#     User u
# WHERE
#     u.id = 1
spring.jpa.properties.hibernate.format_sql=true

# ----------------------------------------------------------------------------

# JDBC connection string za SQL Server
# Povezuje se na lokalni SQL Server (localhost:1433), na bazu JavaAdv
# Opcije za enkripciju (encrypt=true) i trust server certifikata (trustServerCertificate=true)
spring.datasource.url=jdbc:sqlserver://localhost:1433;databaseName=JavaAdv;encrypt=true;trustServerCertificate=true

# Korisnicko ime za pristup bazi podataka (SQL Server 'sa' account)
spring.datasource.username=sa

# Lozinka za pristup bazi podataka
spring.datasource.password=SQL

# Driver klasa za SQL Server JDBC konekciju
spring.datasource.driver-class-name=com.microsoft.sqlserver.jdbc.SQLServerDriver

# Optimizira SQL upite za SQL Server specificnosti
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.SQLServerDialect

# Prikazuje generirane SQL upite u logovima (korisno za debugiranje)
spring.jpa.show-sql=true

# Detaljni SQL logovi
# DEBUG nivo logiranja za Hibernate SQL upite
# Prikazuje sve izvrsene SQL upite
logging.level.org.hibernate.SQL=DEBUG

# TRACE nivo logiranja za Hibernate tipove parametara
# Prikazuje vrednosti parametara u SQL upitima
logging.level.org.hibernate.type=TRACE

# Ova postavka ukljucuje TRACE logging za Hibernateove SQL parametre,
# sto znaci da ce se u logovima prikazivati stvarno proslijedene vrijednosti
# umjesto samo upita sa ? placeholdera. Korisno za dubinsko debugiranje SQL upita i parametara.
# Koristi se:
# Za otkrivanje problema s bindingom parametara
# Za provjeru stvarnih vrijednosti u upitima
# Samo za razvoj (iskljuciti u produkciji zbog opseznog logiranja).
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ----------------------------------------------------------------------------

# Spring Security logovi
# Kratak komentar:
# Ova postavka ukljucuje DEBUG logiranje za Spring Security, sto znaci da cete u logovima vidjeti:
# Tko se prijavljuje (autentikacijski pokusaji)
# Koje se role/provjere izvrsavaju (@PreAuthorize, hasRole...)
# Kako se zahtjevi procesiraju (filter chain, auth provideri)
#
# Primjer loga:
# DEBUG 12345 - [nio-8080-exec-1] o.s.s.web.DefaultSecurityFilterChain:
# Applying security to GET /api/admin
# Roles required: [ADMIN]
# User roles: [USER] - **ACCESS DENIED**
#
# Koristi se za:
# Debugiranje zasto zahtjev nije prosao
# Pracenje tko i kako pristupa API-ju
# Provjeru konfiguracije sigurnosnih pravila
#
# Samo za razvoj (u produkciji iskljucite zbog osjetljivih podataka u logovima).
logging.level.org.springframework.security=DEBUG

# ----------------------------------------------------------------------------

# Logiranje specificno za odredeni projekt po nazivu i lokaciji paketa
#
# Osnovni paket aplikacije
logging.level.hr.java.web.p315=DEBUG
# Logiranje JWT komponenti (tocne putanje)
logging.level.hr.java.web.p315.filter.JwtAuthFilter=TRACE
logging.level.hr.java.web.p315.service.JwtService=TRACE

# sto postizete?
# logging.level.hr.java.web.p315=DEBUG
# Ukljucuje DEBUG nivo za cijeli vas aplikacijski paket (hr.java.web.p315 i sve podpakete).
# Prikazuje korisne informacije o toku aplikacije (npr. servisi, repositoryji).
#
# logging.level.hr.java.web.p315.filter.JwtAuthFilter=TRACE
# Za JwtAuthFilter koristi TRACE (jos detaljnije od DEBUG).
# Pratite svaki korak autentikacije (primljeni token, provjere, greske).
#
# logging.level.hr.java.web.p315.service.JwtService=TRACE
# Detaljno logira generiranje/validaciju JWT tokena (payload, potpis, expiration).
#
# Zasto je ovo dobro?
# Hierarhijski pristup: Opceniti DEBUG za cijelu app + specificni TRACE za kljucne komponente.
# Preglednost: Lako filtrirate logove po paketima (hr.java.web.p315.filter.*).
# Sigurnost: TRACE nivo otkriva samo sto vam treba za debug (npr. ne logira se cijeli token, vec samo metadata).
#
# Napomene
# TRACE je za razvoj - iskljucite u produkciji (osjetljivi podaci/performanse).
# Ako vam treba manje detalja, smanjite na DEBUG.
#
# Primjer loga (TRACE)
# TRACE 12345 - [nio-8080-exec-1] h.j.w.p315.filter.JwtAuthFilter:
# Token received: Bearer eyJhbGci...
# Extracted username: admin@example.com
# Validation: OK (expires at 2025-07-22T12:00:00Z)

# ----------------------------------------------------------------------------

# Port na kojem se Spring Boot aplikacija slusati zahtjeve
server.port=8083

# Onemogucavanje Spring Security automatskog ukljucivanja
# Ukloniti Using generated security password poruku.
# Ukloniti login formu i Basic Auth zastitu s endpointa
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,org.springframework.boot.actuate.autoconfigure.security.servlet.ManagementWebSecurityAutoConfiguration

# JWT konfiguracija za refresh token trajanje (u milisekundama)
# 604800000 ms = 7 dana
jwt.refresh.token.expiration.ms=604800000

# ----------------------------------------------------------------------------

# KOMENTARI:

# ddl-auto=none i hbm2ddl.auto=none rade slicno, ali je bolje koristiti oba za kompatibilnost
# PhysicalNamingStrategyStandardImpl sprjecava Hibernate da modificira case naziva
# SQL skripte (schema.sql i data.sql) se izvrsavaju pri pokretanju aplikacije
# Dijalekt je bitan za pravilno generiranje SQL upita specificnih za SQL Server
# Logging postavke (DEBUG i TRACE) su veoma korisne za razvoj, ali treba ih onemoguciti u produkciji

# Schema je siri pojam od samih tablica. Ukljucuje:
# Tablice (Tables) - Da, to je glavni dio
# Poveznice izmedu tablica (Foreign Keys)
# Indekse (Indexes)
# Poglede (Views)
# Procedure (Stored Procedures)
# Funkcije (Functions)
# Okidace (Triggers)
# Druge database objekte

# Kljucne razlike:
# Tablica - ima samo jednu tabelu sa kolonama i redovima
# Schema - ima cjelokupnu strukturu baze: sve tablice + veze + indeksi + drugi objekti.
#
# Zasto je vazno razumjeti ovu razliku
# Kada koristite spring.sql.init.schema-locations, pripremate CIJELU strukturu baze.
# Migracije baze podataka (Flyway, Liquibase) rade sa cijelom shemom, ne samo tablicama.
# Schema definira kako aplikacija komunicira sa bazom na strukturnom nivou.

# Kako Spring Boot upravlja redoslijedom:
# Uvijek se prvo izvrsava schema.sql (DDL - Data Definition Language)
# Kreiranje tablica
# Definiranje veza (foreign keys)
# Kreiranje indeksa itd.
# Zatim se izvrsava data.sql (DML - Data Manipulation Language)
# INSERT naredbe
# Pocetni podaci
# Testni podaci

# spring.sql.init.schema-locations=classpath:schema.sql
# Ova linija je nepotrebna ako se vasa DDL skripta (za kreiranje tabela) zove schema.sql \
# i nalazi se u src/main/resources folderu
# Spring Boot ce automatski traziti schema.sql na classpath-u
#
# spring.sql.init.data-locations=classpath:data.sql
# Slicno, ova linija je nepotrebna ako se vasa DML skripta (za unos podataka) zove data.sql \
# i nalazi se u src/main/resources folderu
